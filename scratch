class HeapQueue:
    def __init__(self):
        self.nodes = []
        self.array_indices = []

    def delete_min(self, dist):
        parent_index = 0
        nodetoremove = self.nodes[parent_index]

        heap_end_node = self.nodes[self.size() - 1]

        self.nodes.remove(heap_end_node)

        if self.size() == 0:
            return nodetoremove

        self.nodes[parent_index] = heap_end_node

        self.array_indices[nodetoremove.node_id] = -1
        self.array_indices[heap_end_node.node_id] = parent_index

        while True:
            left_child_index = (parent_index * 2) + 1
            right_child_index = (parent_index * 2) + 2

            # Get parent node and distance
            parent_node = self.nodes[parent_index]
            parent_dist = dist[parent_node.node_id]

            if left_child_index < self.size():
                left_child_node = self.nodes[left_child_index]
                left_child_dist = dist[left_child_node.node_id]
            else:
                left_child_dist = float('inf')
                left_child_node = None

            if right_child_index < self.size():
                right_child_node = self.nodes[right_child_index]
                right_child_dist = dist[right_child_node.node_id]
            else:
                right_child_dist = float('inf')
                right_child_node = None

            parent_swapped = False

            if left_child_dist <= right_child_dist:
                if left_child_dist < parent_dist:
                    self.nodes[parent_index] = left_child_node
                    self.nodes[left_child_index] = parent_node

                    self.array_indices[parent_node.node_id] = left_child_index
                    self.array_indices[left_child_node.node_id] = parent_index

                    parent_index = left_child_index
                    parent_swapped = True
            else:
                if right_child_dist < parent_dist:
                    self.nodes[parent_index] = right_child_node
                    self.nodes[right_child_index] = parent_node

                    self.array_indices[parent_node.node_id] = right_child_index
                    self.array_indices[right_child_node.node_id] = parent_index

                    parent_index = right_child_index
                    parent_swapped = True

            if not parent_swapped:
                break

        return nodetoremove

    # Place new or updated node into correct spot on heap queue
    def decrease_key(self, node):
        if self.array_indices[node.node_id] == -1:
            return

        child_index = self.array_indices[node.node_id]

        while True:
            if child_index == 0:
                break

            child_node = self.nodes[child_index]

            parent_index = (child_index - 1) // 2
            parent_node = self.nodes[parent_index]

            child_dist = dist[child_node.node_id]
            parent_dist = dist[parent_node.node_id]

            if child_dist < parent_dist:

                self.nodes[child_index] = parent_node
                self.nodes[parent_index] = child_node

                self.array_indices[child_node.node_id] = parent_index
                self.array_indices[parent_node.node_id] = child_index

                child_index = parent_index


            else:
                break

    # Insert state into priority heap queue
    def insert(self, node):
        node.queue_index = self.size()

        self.nodes.append(node)
        self.array_indices.append(node.queue_index)
        self.decrease_key(node)

    # Return number of nodes in heap queue
    def size(self):
        return len(self.nodes)